import 'dart:collection';

import 'package:sector/sector.dart';
import 'package:sector/src/utils/sparse_list.dart';

/// A sparse grid implementation using a [SplayTreeMap] to store elements.
///
/// This implementation is a sparse grid, where elements are stored in row-major
/// order, but with default values omitted. This is memory-efficient for grids
/// with large empty regions, but may be slower than a dense grid for many
/// operations.
///
/// ## Examples
///
/// The following grid:
///
/// ```dart
/// final grid = SplayTreeGrid.fromRows([
///   ['a', ' ', 'b'],
///   ['c', ' ', ' '],
///   [' ', ' ', 'd'],
/// ]);
/// print(grid.toSparseMap());
/// ```
///
/// Produces the following output:
///
/// ```txt
/// {0: a, 2: b, 3: c, 8: d}
/// ```
final class SplayTreeGrid<T> with Grid<T>, EfficientIndexGrid<T> {
  /// Creates a new grid with the provided [width] and [height].
  ///
  /// The grid is initialized with all elements set to [fill].
  ///
  /// The [width] and [height] must be non-negative.
  factory SplayTreeGrid.filled(int width, int height, T fill) {
    RangeError.checkNotNegative(width, 'width');
    RangeError.checkNotNegative(height, 'height');
    return SplayTreeGrid._(
      SplayTreeMap(),
      width,
      height,
      fill,
    );
  }

  /// Creates a new grid with the provided [width] and [height].
  ///
  /// The grid is initialized with elements generated by the provided
  /// [generator], where the element at index `(x, y)` is `generator(x, y)`.
  ///
  /// The [width] and [height] must be non-negative.
  ///
  /// When elements are added to the grid with a value of [fill], the grid will
  /// grow to accommodate the new elements, but does not pre-allocate any space;
  /// if not provided, the most common value is used as the default.
  factory SplayTreeGrid.generate(
    int width,
    int height,
    T Function(int x, int y) generator, {
    T? fill,
  }) {
    RangeError.checkNotNegative(width, 'width');
    RangeError.checkNotNegative(height, 'height');

    // If fill is provided, this is relatively simple.
    if (fill is T) {
      final cells = SplayTreeMap<int, T>();
      for (var index = 0; index < width * height; index++) {
        final x = index % width;
        final y = index ~/ width;
        final value = generator(x, y);
        if (value != fill) {
          cells[index] = value;
        }
      }
      return SplayTreeGrid._(cells, width, height, fill);
    }

    // Otherwise, we need to pre-generate the cells to find the most common.
    final cells = <int, T>{
      for (var y = 0; y < height; y++)
        for (var x = 0; x < width; x++) y * width + x: generator(x, y),
    };
    final fill_ = GridImpl.mostCommonElement(cells.values);

    // Remove the fill values from the cells.
    cells.removeWhere((_, value) => value == fill_);

    // Create the grid with the cells and fill value.
    return SplayTreeGrid._(SplayTreeMap.of(cells), width, height, fill_);
  }

  /// Creates a new grid from an existing [grid].
  ///
  /// The new grid is a shallow copy of the original grid.
  ///
  /// When elements are added to the grid with a value of [fill], the grid will
  /// grow to accommodate the new elements, but does not pre-allocate any space;
  /// if not provided, the most common value is used as the default.
  factory SplayTreeGrid.from(
    Grid<T> grid, {
    T? fill,
  }) {
    return SplayTreeGrid.generate(
      grid.width,
      grid.height,
      grid.getUnchecked,
      fill: fill,
    );
  }

  /// Creates a new grid from the provided [rows].
  ///
  /// Each row must have the same length, and the grid will have a width equal
  /// to the length of the first row, and a height equal to the number of rows.
  ///
  /// The grid is initialized with the elements in the rows, where the element
  /// at index `(x, y)` is `rows[y][x]`.
  ///
  /// When elements are added to the grid with a value of [fill], the grid will
  /// grow to accommodate the new elements, but does not pre-allocate any space;
  /// if not provided, the most common value is used as the default.
  factory SplayTreeGrid.fromRows(
    Iterable<Iterable<T>> rows, {
    T? fill,
  }) {
    final cells = GridImpl.checkedExpand(rows).toList();
    final width = rows.isEmpty ? 0 : rows.first.length;
    final fill_ = fill ?? GridImpl.mostCommonElement<T>(cells);
    final map = SplayTreeMap<int, T>();
    var i = 0;
    for (final cell in cells) {
      if (cell != fill_) {
        map[i] = cell;
      }
      i++;
    }

    return SplayTreeGrid._(
      map,
      width,
      width != 0 ? cells.length ~/ width : 0,
      fill_,
    );
  }

  /// Creates a new grid from the provided [columns].
  ///
  /// Each column must have the same length, and the grid will have a width
  /// equal to the number of columns, and a height equal to the length of the
  /// first column.
  ///
  /// The grid is initialized with the elements in the columns, where the
  /// element at index `(x, y)` is `columns[x][y]`.
  ///
  /// When elements are added to the grid with a value of [fill], the grid will
  /// grow to accommodate the new elements, but does not pre-allocate any space;
  /// if not provided, the most common value is used as the default.
  factory SplayTreeGrid.fromColumns(
    Iterable<Iterable<T>> columns, {
    T? fill,
  }) {
    return SplayTreeGrid.fromRows(
      GridImpl.transpose(columns),
      fill: fill,
    );
  }

  /// Creates a new empty grid.
  ///
  /// The grid has a [width] and [height] of `0`.
  ///
  /// When elements are added to the grid with a value of [fill], the grid will
  /// grow to accommodate the new elements, but does not pre-allocate any space.
  factory SplayTreeGrid.empty(T fill) {
    return SplayTreeGrid._(SplayTreeMap(), 0, 0, fill);
  }

  /// Creates a new grid that is a _view_ of [cells] in row-major order.
  ///
  /// The [cells] must have a length equal to the product of the [width] and
  /// [height], and the grid will have a width and height equal to the provided
  /// dimensions.
  ///
  /// If either the [cells] length is not equal to `width * height`, the keys
  /// are not within the range `0` to `width * height`, or the [fill] value is
  /// present in the [cells], the behavior is undefined.
  factory SplayTreeGrid.view(
    SplayTreeMap<int, T> cells, {
    required int width,
    required int height,
    required T fill,
  }) {
    RangeError.checkNotNegative(width, 'width');
    RangeError.checkNotNegative(height, 'height');
    return SplayTreeGrid._(
      cells,
      width,
      height,
      fill,
    );
  }

  SplayTreeGrid._(
    SplayTreeMap<int, T> cells,
    this._width,
    int height,
    T fill,
  ) : _cells = SparseList.view(cells, length: _width * height, fill: fill);

  final SparseList<T> _cells;

  @override
  int get width => _width;
  int _width;

  @override
  int get height => width == 0 ? 0 : _cells.length ~/ width;

  @override
  GridAxis<T> get rows => _Rows(this);

  @override
  GridAxis<T> get columns => _Columns(this);

  @pragma('vm:prefer-inline')
  int _index(int x, int y) => x + y * _width;

  @override
  T getUnchecked(int x, int y) {
    return _cells[_index(x, y)];
  }

  @override
  void setUnchecked(int x, int y, T value) {
    _cells[_index(x, y)] = value;
  }

  @override
  bool contains(T element) => _cells.contains(element);

  @override
  LayoutHint get layoutHint => LayoutHint.rowMajorContiguous;

  @override
  T getByIndexUnchecked(int index) => _cells[index];

  /// Returns a sparse map of the grid, with fill values omitted.
  ///
  /// The map is ordered by key, where the key is the index in the grid.
  Map<int, T> toSparseMap() => _cells.toSparseMap();
}

final class _Rows<T> extends GridAxis<T> with RowsMixin<T> {
  _Rows(this.grid);

  @override
  final SplayTreeGrid<T> grid;

  @override
  void insertAt(int index, Iterable<T> row) {
    // If the grid is empty, and index is 0, this is the first row.
    if (grid.isEmpty && index == 0) {
      grid._cells.insertAll(0, row);
      grid._width = row.length;
      return;
    }

    GridImpl.checkBoundsInclusive(grid, 0, index);
    GridImpl.checkLength(row, grid.width, name: 'row');

    final start = index * grid.width;
    grid._cells.insertAll(start, row);
  }

  @override
  void removeAt(int index) {
    GridImpl.checkBoundsExclusive(grid, 0, index);

    final start = index * grid.width;
    grid._cells.removeRange(start, start + grid.width);
  }
}

final class _Columns<T> extends GridAxis<T> with ColumnsMixin<T> {
  _Columns(this.grid);

  @override
  final SplayTreeGrid<T> grid;

  @override
  void insertAt(int index, Iterable<T> column) {
    // If the grid is empty, and index is 0, this is the first column.
    if (grid.isEmpty && index == 0) {
      grid._cells.insertAll(0, column);
      grid._width = 1;
      return;
    }

    GridImpl.checkBoundsInclusive(grid, 0, index);
    GridImpl.checkLength(column, grid.height, name: 'column');

    final columnList = List.of(column);

    // Insert in reverse order to avoid shifting elements unnecessarily.
    for (var y = grid.height - 1; y >= 0; y--) {
      final start = index + y * grid.width;
      grid._cells.insertAll(start, [columnList[y]]);
    }

    grid._width += 1;
  }

  @override
  void removeAt(int index) {
    GridImpl.checkBoundsExclusive(grid, 0, index);

    // Remove in reverse order to avoid shifting elements unnecessarily.
    for (var y = grid.height - 1; y >= 0; y--) {
      final start = index + y * grid.width;
      grid._cells.removeRange(start, start + 1);
    }

    grid._width -= 1;
  }
}
