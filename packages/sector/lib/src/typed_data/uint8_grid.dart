part of '../typed_data_grid.dart';

/// A grid of 8-bit unsigned integer cells.
final class Uint8Grid extends TypedDataGrid<int, Uint8List> {
  static final _empty = Uint8List(0);

  /// Creates a new grid with the provided [width] and [height].
  ///
  /// The [width] and [height] must be non-negative.
  ///
  /// If [fill] is provided, all cells will be initialized to that value.
  factory Uint8Grid.filled(int width, int height, [int fill = 0]) {
    RangeError.checkNotNegative(width, 'width');
    RangeError.checkNotNegative(height, 'height');
    final cells = Uint8List(width * height);
    if (fill != 0) {
      cells.fillRange(0, cells.length, fill);
    }
    return Uint8Grid.withBytes(cells, width: width);
  }

  /// Creates a new grid with the provided [width] and [height].
  ///
  /// The grid is initialized with elements generated by the provided
  /// [generator], where the element at index `(x, y)` is `generator(x, y)`.
  ///
  /// The [width] and [height] must be non-negative.
  factory Uint8Grid.generate(
    int width,
    int height,
    int Function(int x, int y) generator,
  ) {
    RangeError.checkNotNegative(width, 'width');
    RangeError.checkNotNegative(height, 'height');
    final cells = Uint8List(width * height);
    _buildIntHelper(cells, generator, width: width);
    return Uint8Grid.withBytes(cells, width: width);
  }

  /// Creates a new grid from the provided [grid].
  factory Uint8Grid.from(Grid<int> grid) {
    return Uint8Grid.generate(
      grid.width,
      grid.height,
      grid.getUnchecked,
    );
  }

  /// Creates a new grid from the provided [cells].
  ///
  /// The grid will have a width equal to the provided [width], and a height
  /// equal to the number of cells divided by the width, which must be an
  /// integer.
  ///
  /// The grid is initialized with the elements in the cells, where the element
  /// at index `(x, y)` is `cells[y * width + x]`.
  ///
  /// If [width] is `0`, an [Grid.empty] is returned.
  factory Uint8Grid.fromCells(Iterable<int> cells, {required int width}) {
    if (cells.isEmpty || width == 0) {
      return Uint8Grid.empty();
    }
    return Uint8Grid.withBytes(
      Uint8List.fromList(List.of(cells)),
      width: width,
    );
  }

  /// Creates a new grid from the provided [rows].
  ///
  /// Each row must have the same length, and the grid will have a width equal
  /// to the length of the first row, and a height equal to the number of rows.
  ///
  /// The grid is initialized with the elements in the rows, where the element
  /// at index `(x, y)` is `rows[y][x]`.
  factory Uint8Grid.fromRows(Iterable<Iterable<int>> rows) {
    return Uint8Grid.withBytes(
      Uint8List.fromList(rows.expand((row) => row).toList()),
      width: rows.isEmpty ? 0 : rows.first.length,
    );
  }

  /// Creates a new grid from the provided [columns].
  ///
  /// Each column must have the same length, and the grid will have a width
  /// equal to the number of columns, and a height equal to the length of the
  /// first column.
  ///
  /// The grid is initialized with the elements in the columns, where the
  /// element at index `(x, y)` is `columns[x][y]`.
  factory Uint8Grid.fromColumns(Iterable<Iterable<int>> columns) {
    final width = columns.length;
    final height = columns.isEmpty ? 0 : columns.first.length;
    final cells = Uint8List(width * height);
    _fromIntColsHelper(cells, columns);
    return Uint8Grid.withBytes(cells, width: width);
  }

  /// Creates a new empty grid.
  ///
  /// The grid has a width and height of `0` and will not contain any elements.
  Uint8Grid.empty() : super._(_empty, 0);

  /// Creates a new grid that uses [cells] as its backing store.
  ///
  /// The [cells] list must have a length that is a multiple of [width].
  ///
  /// The [width] must be non-negative.
  Uint8Grid.withBytes(
    Uint8List cells, {
    required int width,
  }) : super._(cells, width);

  @pragma('vm:prefer-inline')
  @override
  int getUnchecked(int x, int y) {
    return _data[x + y * width];
  }

  @pragma('vm:prefer-inline')
  @override
  void setUnchecked(int x, int y, int value) {
    _data[x + y * width] = value;
  }
}
